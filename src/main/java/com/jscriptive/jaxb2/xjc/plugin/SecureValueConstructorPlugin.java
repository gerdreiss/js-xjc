package com.jscriptive.jaxb2.xjc.plugin;

import com.sun.codemodel.*;
import com.sun.tools.xjc.Options;
import com.sun.tools.xjc.Plugin;
import com.sun.tools.xjc.outline.ClassOutline;
import com.sun.tools.xjc.outline.Outline;
import org.xml.sax.ErrorHandler;

import java.util.*;


public class SecureValueConstructorPlugin extends Plugin {

    @Override
    public String getOptionName() {
        return "Xsecure-value-constructor";
    }

    @Override
    public String getUsage() {
        return "  -Xsecure-value-constructor    : implement security requirements when generating classes: clone Date objects when using them as constructor params";
    }

    @Override
    public boolean run(final Outline outline, final Options options, final ErrorHandler errorHandler) {

        // For each defined class
        for (final ClassOutline classOutline : outline.getClasses()) {
            final JDefinedClass implClass = classOutline.implClass;

            // Create the default, no-arg constructor
            final JMethod defaultConstructor = implClass.constructor(JMod.PUBLIC);
            defaultConstructor.javadoc().add("Default no-arg constructor");
            defaultConstructor.body().invoke("super");

            final Collection<JFieldVar> superClassInstanceFields = getInstanceFields(getSuperclassFields(implClass));
            final Collection<JFieldVar> thisClassInstanceFields = getInstanceFields(implClass.fields().values());

            final boolean doGenerateValueConstructor = !superClassInstanceFields.isEmpty() || !thisClassInstanceFields.isEmpty();

            // If the class or its (generated) superclass has fields, then generate a value constructor
            if (doGenerateValueConstructor) {

                // Create the skeleton of the value constructor
                final JMethod valueConstructor = implClass.constructor(JMod.PUBLIC);
                valueConstructor.javadoc().add("Fully-initialising value constructor");

                // If our superclass is also being generated, then we can assume it will also have
                // its own value constructor, so we add an invocation of that constructor.
                if (implClass._extends() instanceof JDefinedClass) {

                    final JInvocation superInvocation = valueConstructor.body().invoke("super");

                    // Add each argument to the super constructor.
                    for (JFieldVar superClassField : superClassInstanceFields) {
                        if (generateConstructorParameter(superClassField)) {
                            final JVar arg = valueConstructor.param(JMod.FINAL, superClassField.type(), superClassField.name());
                            superInvocation.arg(arg);
                        }
                    }
                }

                // Now add constructor parameters for each field in "this" class, and assign them to our fields.
                for (final JFieldVar field : thisClassInstanceFields) {
                    if (generateConstructorParameter(field)) {
                        final JVar arg = valueConstructor.param(JMod.FINAL, field.type(), field.name());
                        if (Date.class.getSimpleName().equals(field.type().name())) {
                            JConditional condition = valueConstructor.body()._if(JExpr.ref(field.name()).eq(JExpr._null()));
                            condition._then().assign(JExpr.refthis(field.name()), JExpr._null());
                            condition._else().assign(JExpr.refthis(field.name()), JExpr.cast(field.type(), JExpr.ref(field.name()).invoke("clone")));
                        } else {
                            valueConstructor.body().assign(JExpr.refthis(field.name()), arg);
                        }
                    }
                }
            }
        }

        return true;
    }

    /**
     * Takes a collection of fields, and returns a new collection containing only the instance
     * (i.e. non-static) fields.
     */
    protected Collection<JFieldVar> getInstanceFields(final Collection<JFieldVar> fields) {
        final List<JFieldVar> instanceFields = new ArrayList<JFieldVar>();
        for (final JFieldVar fieldVar : fields) {
            final boolean isStaticField = (fieldVar.mods().getValue() & JMod.STATIC) != 0;
            if (!isStaticField) {
                instanceFields.add(fieldVar);
            }
        }
        return instanceFields;
    }

    /**
     * Whether or not to generate a constructor parameter for the given field.
     */
    protected boolean generateConstructorParameter(final JFieldVar field) {
        final boolean isStaticField = (field.mods().getValue() & JMod.STATIC) > 0;
        return !isStaticField;
    }

    /**
     * Retrieve a List of the fields of each ancestor class. I walk up the class hierarchy
     * until I reach a class that isn't being generated by JAXB.
     */
    protected List<JFieldVar> getSuperclassFields(final JDefinedClass implClass) {
        final List<JFieldVar> fieldList = new LinkedList<JFieldVar>();

        JClass superclass = implClass._extends();
        while (superclass instanceof JDefinedClass) {
            fieldList.addAll(0, ((JDefinedClass) superclass).fields().values());
            superclass = superclass._extends();
        }

        return fieldList;
    }
}
